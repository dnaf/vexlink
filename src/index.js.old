const Promise = require('bluebird');

const _ = require('lodash');
const cp = Promise.promisifyAll(require('child_process'));
const debug = require('debug')('vexlink');
const fs = Promise.promisifyAll(require('fs'));
const gamepad = require('gamepad');
const midi = require('midi');
const mpd = require('mpd');

const MUSIC_PROGRESS_BAR = ['esc', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12'];
const WORKSPACE_BAR = ['grave', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
const PACMAN_UPDATE_BAR = ['end', 'home', 'scroll'];
const AUR_UPDATE_BAR = ['pgdn', 'pgup', 'pause'];


debug('Connecting to MPD');
const mpdClient = Promise.promisifyAll(mpd.connect());

function hexToRGB(hex) {
	const r = hex >>> 16;
	const g = (hex >>> 8) & 0xFF;
	const b = hex & 0xFF;
	return [r, g, b];
}
function rgbToHex(r, g, b) {
	return (Math.floor(r) << 16) + (Math.floor(g) << 8) + Math.floor(b);
}

async function drawProgressBar(keys, value, background, foreground) {
	const foregroundWidth = Math.floor(value * keys.length);
	const ditheredKey = Math.ceil(value * keys.length) - 1;
	const ditheredAmount = (value * keys.length) % 1;

	const [br, bg, bb] = hexToRGB(background);
	const [fr, fg, fb] = hexToRGB(foreground);
	const ditheredColor = rgbToHex(
		br + (ditheredAmount * (fr - br)),
		bg + (ditheredAmount * (fg - bg)),
		bb + (ditheredAmount * (fb - bb)),
	);

	const commands = [];

	commands.push('rgb ' + keys.join(',') + ':' + _.padStart(background.toString(16), 6, '0')); // Draw background

	if (foregroundWidth > 0) {
		commands.push('rgb ' + _.take(keys, foregroundWidth).join(',') + ':' + _.padStart(foreground.toString(16), 6, '0')); // Draw foreground
	}

	commands.push('rgb ' + keys[ditheredKey] + ':' + _.padStart(ditheredColor.toString(16), 6, '0')); // Draw dithered pixel

	return fs.appendFileAsync('/dev/input/ckb2/cmd', commands.join(' ') + '\n');
}

async function updateMusicProgressBar() {
	const status = await mpdClient.sendCommandAsync('status')
		.then(mpd.parseKeyValueMessage);

	if (status.elapsed && status.duration) {
		const progress = Number(status.elapsed) / Number(status.duration);

		const volume = Number(status.volume) / 100;

		const background = 0;
		const foreground = rgbToHex(0x7F + 0x7F * volume, 0x10, 0x30 * volume);

		drawProgressBar(MUSIC_PROGRESS_BAR, progress, background, foreground);
	}
}
setInterval(updateMusicProgressBar, 100);

async function updateWorkspaceBar() {
	const commands = [
		'rgb ' + WORKSPACE_BAR.join(',') + ':000000'
	];

	const workspaces = JSON.parse(await cp.execAsync('i3-msg -t get_workspaces'));

	for (const i in workspaces) {
		const workspace = workspaces[i];
		const key = WORKSPACE_BAR[workspace.num];

		if (key) {
			let color = '000020';
			if (workspace.focused) {
				color = 'FF00FF';
			} else if (workspace.visible) {
				color = '0000FF';
			}
			commands.push('rgb ' + key + ':' + color);
		}
	}
	return fs.appendFileAsync('/dev/input/ckb2/cmd', commands.join(' ') + '\n');
}
setInterval(updateWorkspaceBar, 50);

async function updateUpdateBar() {
	const pacmanUpdates = ((await cp.execAsync('checkupdates', {encoding: 'utf8'})).match(/.+\n/g) || []).length;
	const aurUpdates = ((await cp.execAsync('pacaur -k', {encoding: 'utf8'}).catch(err => {
		return '';
	})).match(/.+\n/g) || []).length;

	drawProgressBar(PACMAN_UPDATE_BAR, (0.5 + Math.log(pacmanUpdates) / Math.log(4)) / 4, 0x000000, 0x00FF00);
	drawProgressBar(AUR_UPDATE_BAR, (0.5 + Math.log(aurUpdates) / Math.log(4)) / 4, 0x000000, 0x00FF00);
}
setInterval(updateUpdateBar, 10000);
updateUpdateBar();

//debug('Initializing gamepad');
//gamepad.init();

/*
debug('Initializing MIDI I/O');
const midiInput = new midi.input();
let midiPort;
for (let i = 0; i < midiInput.getPortCount(); i++) {
	if (midiInput.getPortName(i).match(/vortex/i)) {
		midiPort = i;
		break;
	}
}
if (!midiPort) {
	throw new Error('Couldn\'t find Vortex midi port');
}
midiInput.openPort(midiPort);
process.on('exit', midiInput.closePort);
*/

async function setMPDVolume(value) {
	return mpdClient.sendCommandAsync('setvol ' + Math.floor(value * 100));
}

/*
midiInput.on('message', (dt, m) => {
	if (m[0] === 176) { // If it's a control change
		const [status, controller, value] = m;
		if (controller === 73) {
			return setMPDVolume(value / 127);
		}
	}
});
*/

/* Gamepad.on("move", (id, axis, value) => {
	debug(id);
	if (id === 1 && axis == 4) {
		if (value > -0.1 && value < 0.1) {
			value = 0;
		}
		value = value * -0.5 + 0.5
		setMPDVolume(value);
	}
});
*/
