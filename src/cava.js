const Promise = require("bluebird");

const _ = require("lodash");
const cp = require("child_process");
const EventEmitter = require("events");
const fs = Promise.promisifyAll(require("fs"));
const ini = require("ini");
const Path = require("path");

class Cava extends EventEmitter {
	/**
	 * @param {Object} [options]
	 * @param {number} [options.framerate=60]
	 * @param {number} [options.sensitivity] The sensitivity in percent. If undefined, use auto sensitivity.
	 * @param {number} [options.bars=200]
	 * @param {number[2]} [options.range=[50, 10000]] The lower and higher cutoff frequencies in Hz
	 * @param {boolean} [options.stereo=false]
	 * @param {number} [options.bitDepth=16] Either 8 or 16
	 *
	 * @param {Object} [options.input]
	 * @param {string} [options.input.method=pulse]
	 * @param {string} [options.input.source=auto]
	 *
	 * @param {number} [options.integralSmoothing=70]
	 * @param {boolean} [options.monstercatSmoothing=true]
	 * @param {boolean} [options.monstercatWaves=false]
	 *
	 * @param {number} [options.gravity=100]
	 */
	constructor(callback, options) {
		super();

		options = options || {};

		_.defaultsDeep(options, {
			framerate: 60,
			sensitivity: undefined,
			bars: 200,
			range: [50, 10000],
			stereo: false,
			bitDepth: 16,

			input: {
				method: "pulse",
				source: "auto"
			},

			integralSmoothing: 70,
			monstercatSmoothing: true,
			monstercatWaves: false,

			gravity: 100,

			ignoreHeight: 0
		});

		this._options = options;
		this._id = Number(new Date()) + Math.floor(Math.random() * 99);
		this._cb = callback;

		console.log(this._configPath);

		this._run();
	}

	get _configPath() {
		return Path.join("/tmp/", "cava" + this._id + ".conf");
	}
	get _fifoPath() {
		return Path.join("/tmp/", "cava" + this._id + ".fifo");
	}

	get _config() {
		/* eslint-disable camelcase */
		const config = {
			general: {
				framerate: this._options.framerate,
				autosens: (typeof (this._options.sensitivity) === "number") ? 0 : 1,
				bars: this._options.bars,
				lower_cutoff_freq: this._options.range[0],
				higher_cutoff_freq: this._options.range[1]
			},
			input: {
				method: this._options.input.method,
				source: this._options.input.source
			},
			output: {
				method: "raw",
				channels: this._options.stereo ? "stereo" : "mono",

				raw_target: this._fifoPath,
				data_format: "binary",
				bit_format: this._options.bitDepth + "bit"
			},
			smoothing: {
				integral: this._options.integralSmoothing,
				monstercat: this._options.monstercatSmoothing ? 1 : 0,
				waves: this._options.monstercatWaves ? 1 : 0,
				gravity: this._options.gravity
			}
		};

		if (this._options.sensitivity) {
			config.general.sensitivity = this._options.sensitivity;
		}

		return config;
		/* eslint-enable camelcase */
	}

	get _configString() {
		return "# auto-generated by vexlink " + new Date() + "\n\n" + ini.encode(this._config, {whitespace: true});
	}

	async _writeConfig() {
		await fs.writeFileAsync(this._configPath, this._configString);
		return this._configPath;
	}

	async _run() {
		this._process = cp.spawn("/usr/bin/cava", ["-p", await this._writeConfig()]);

		const watcher = fs.watch(Path.dirname(this._fifoPath), (e, file) => {
			if (file === Path.basename(this._fifoPath)) {
				watcher.close();
				this._stream = fs.createReadStream(this._fifoPath);
				// This._stream.on("readable", (data) => { this._read() });
				setInterval(() => {
					this._read();
				}, 1);
			}
		});
	}

	_read() {
		const byteDepth = this._options.bitDepth / 8;
		const data = this._stream.read(this._options.bars * byteDepth);

		if (data) {
			const bars = [];
			for (let bar = 0; bar * byteDepth < data.length && bar < this._options.bars; bar++) {
				let value;
				for (let b = 0; b < byteDepth; b++) {
					value <<= 8;
					value += data.readUInt8(bar * byteDepth + b);
				}
				value /= Math.pow(2, this._options.bitDepth);
				bars[bar] = value;
			}
			this._cb(bars);
		}
	}
}

module.exports = Cava;
